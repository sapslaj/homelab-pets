local log = require("log")
local http = require("http")

local reverse_lookup_filter = function (endpoint)
  local log_labels = {
    filter_direction = "reverse",
    hostname = endpoint.hostname,
    source = endpoint.source_properties.source,
    dhcp_pool = endpoint.source_properties.dhcp_pool,
  }
  if endpoint.hostname == "" then
    log.info("endpoint hostname is blank", log_labels)
    return false
  end
  local skip_hostnames = {
    "ubuntu",
    "sync",
  }
  for _, v in pairs(skip_hostnames) do
    if v == endpoint.hostname then
      log.info("endpoint's hostname is in the skip list", log_labels)
      return false
    end
  end
  return true
end

local forward_lookup_filter = function(endpoint)
  local log_labels = {
    filter_direction = "forward",
    hostname = endpoint.hostname,
    source = endpoint.source_properties.source,
    dhcp_pool = endpoint.source_properties.dhcp_pool,
  }
  if endpoint.source_properties.source == "shimiko" then
    log.info("skipping updating forward lookup record for shimiko-managed record", log_labels)
    return false
  end
  if endpoint.source_properties.static then
    log.info("endpoint is static, allowing", log_labels)
    return true
  end
  if endpoint.source_properties.dhcp_pool == "LAN_Management" then
    log.info("endpoint is in LAN_Management, allowing", log_labels)
    return true
  elseif endpoint.source_properties.dhcp_pool == "LAN_Servers" then
    local skip_hostnames = {
      "aqua",
      "shimiko",
      "ubuntu",
    }
    for _, v in pairs(skip_hostnames) do
      if v == endpoint.hostname then
        log.info("endpoint is in LAN_Servers and should be skipped", log_labels)
        return false
      end
    end
    log.info("endpoint is in LAN_Servers", log_labels)
    return true
  elseif endpoint.source_properties.dhcp_pool == "LAN_Internal" then
    local allowed_hostnames = {
      "homeassistant",
      "darkness",
      "playboy",
      "k3sdev",
      "steamdeck",
      "megumin",
      "silverwolf",
      "prusa-mk4",
    }
    for _, v in pairs(allowed_hostnames) do
      if v == endpoint.hostname then
        log.info("endpoint is in LAN_Internal and is an allowed hostname", log_labels)
        return true
      end
    end
    local allowed_hostname_parts = {
      "air%-q",
      "BroadLink",
      "shelly",
    }
    for _, v in pairs(allowed_hostname_parts) do
      if string.find(endpoint.hostname, v) then
        log.info("endpoint is in LAN_Internal and contains allowed hostname part", log_labels)
        return true
      end
    end
  end
  log.info("endpoint is not explicitly handled so skipping", log_labels)
  return false
end

local hosts_file_generate = function(suffix)
  return function(endpoints)
    local result = ""
    result = result .. "# Generated by ZonePop\n"
    for _, endpoint in pairs(endpoints) do
      for _, ipv4 in pairs(endpoint.ipv4s or {}) do
        result = result .. ipv4 .. "\t" .. endpoint.hostname .. suffix .. "\n"
      end
      for _, ipv6 in pairs(endpoint.ipv6s or {}) do
        result = result .. ipv6 .. "\t" .. endpoint.hostname .. suffix .. "\n"
      end
    end
    return result
  end
end

local rdns_zone_generate = function(zone, nameservers)
  return function(_, ptr_records)
    local result = ""
    result = result .. "$ORIGIN " .. zone .. "\n"
    result = result .. "$TTL 300\n"
    local serial = math.floor(math.random(0, 65535))
    result = result .. "@ IN SOA " .. nameservers[1] .. " awsdns-hostmaster.amazon.com. " .. serial .. " 7200 900 1209600 8640\n"
    for _, ns in pairs(nameservers) do
      result = result .. "@ IN NS " .. ns .. "\n"
    end
    for _, ptr in pairs(ptr_records) do
      result = result .. ptr.rfc1035_domain_name .. " IN PTR " .. ptr.full_hostname .. ".\n"
    end
    return result
  end
end

local coredns_files_config = {
  {
    filename = "/etc/coredns/zonepop.hosts",
    record_suffix = ".sapslaj.xyz",
    generate = hosts_file_generate(".sapslaj.xyz"),
  },
  {
    filename = "/etc/coredns/24.172.in-addr.arpa.zone",
    zone = "24.172.in-addr.arpa.",
    record_suffix = ".sapslaj.xyz",
    generate = rdns_zone_generate("24.172.in-addr.arpa.", {
      "rem.sapslaj.xyz.",
      "ram.sapslaj.xyz.",
      -- "ns-1239.awsdns-26.org.",
      -- "ns-74.awsdns-09.com.",
      -- "ns-1659.awsdns-15.co.uk.",
      -- "ns-901.awsdns-48.net.",
    })
  },
  {
    filename = "/etc/coredns/2.2.0.e.0.7.4.0.1.0.0.2.ip6.arpa.zone",
    zone = "2.2.0.e.0.7.4.0.1.0.0.2.ip6.arpa.",
    record_suffix = ".sapslaj.xyz",
    generate = rdns_zone_generate("2.2.0.e.0.7.4.0.1.0.0.2.ip6.arpa.", {
      "ns-837.awsdns-40.net.",
      "ns-1112.awsdns-11.org.",
      "ns-2034.awsdns-62.co.uk.",
      "ns-130.awsdns-16.com.",
    })
  },
}

return {
  sources = {
    shimiko = {
      "custom",
      config = {
        endpoints = function (_)
          local res = http.request({
            url = "http://localhost/v1/dns-records",
          })
          assert(res.status_code == 200, "shimiko request failed: status="..res.status_code..", body="..res.body)
          local allowed_names = {
            "aqua",
            "daki",
            "mitsuru",
            "pdu1",
            "pdu2",
            "ram",
            "rem",
            "shiroko",
            "taiga",
            "ups1",
            "yor",
          }
          local endpoint_map = {}
          for _, record in pairs(res.json()["records"]) do
            local log_labels = {
              record_name = record.name,
              record_type = record.type,
            }
            local allowed_name = false
            for _, v in pairs(allowed_names) do
              if v == record.name then
                allowed_name = true
              end
            end
            if not allowed_name then
              log.info("shimiko record name is not allowlisted, skipping", log_labels)
              goto continue
            end
            if record.type ~= "A" and record.type ~= "AAAA" then
              log.info("shimiko record is not A or AAAA, skipping", log_labels)
              goto continue
            end
            if endpoint_map[record.name] == nil then
              endpoint_map[record.name] = {
                ipv4s = {},
                ipv6s = {},
              }
            end
            if record.ttl ~= nil then
              endpoint_map[record.name].ttl = record.ttl
            end
            if record.type == "A" then
              for _, value in pairs(record.records) do
                endpoint_map[record.name].ipv4s[value] = true
              end
            else
              for _, value in pairs(record.records) do
                endpoint_map[record.name].ipv6s[value] = true
              end
            end
            ::continue::
          end

          local endpoints = {}

          for hostname, data in pairs(endpoint_map) do
            local endpoint = {
              hostname = hostname,
            }

            if data.ttl ~= nil then
              endpoint.ttl = data.ttl
            end

            for ipv4, marker in pairs(data.ipv4s) do
              if endpoint.ipv4s == nil then
                endpoint.ipv4s = {}
              end
              if marker == true then
                table.insert(endpoint.ipv4s, ipv4)
              end
              table.sort(endpoint.ipv4s)
            end

            for ipv6, marker in pairs(data.ipv6s) do
              if endpoint.ipv6s == nil then
                endpoint.ipv6s = {}
              end
              if marker == true then
                table.insert(endpoint.ipv6s, ipv6)
              end
              table.sort(endpoint.ipv6s)
            end

            table.insert(endpoints, endpoint)
          end

          return endpoints
        end
      },
    },
    vyos = {
      "vyos_ssh",
      config = {
        host = os.getenv("VYOS_HOST"),
        username = os.getenv("VYOS_USERNAME"),
        password = os.getenv("VYOS_PASSWORD"),
        record_ttl = 300,
        collect_ipv6_neighbors = true,
      },
    },
  },
  providers = {
    rem_coredns = {
      "file",
      config = {
        forward_lookup_filter = forward_lookup_filter,
        reverse_lookup_filter = reverse_lookup_filter,
        files = coredns_files_config,
        ssh = {
          host = "rem.sapslaj.xyz",
          username = os.getenv("VYOS_USERNAME"),
          password = os.getenv("VYOS_PASSWORD"),
        },
      },
    },
    ram_coredns = {
      "file",
      config = {
        forward_lookup_filter = forward_lookup_filter,
        reverse_lookup_filter = reverse_lookup_filter,
        files = coredns_files_config,
        ssh = {
          host = "ram.sapslaj.xyz",
          username = os.getenv("VYOS_USERNAME"),
          password = os.getenv("VYOS_PASSWORD"),
        },
      },
    },
    route53 = {
      "aws_route53",
      config = {
        record_suffix = ".sapslaj.xyz",
        forward_zone_id = "Z00048261CEI1B6JY63KT",
        ipv4_reverse_zone_id = "Z00206652RDLR1KV5OQ39",
        ipv6_reverse_zone_id = "Z00734311E53TPLAI5AXC",
        clean_ipv4_reverse_zone = true,
        clean_ipv6_reverse_zone = true,
        forward_lookup_filter = forward_lookup_filter,
        reverse_lookup_filter = reverse_lookup_filter,
      },
    },
    shimiko = {
      "custom",
      config = {
        forward_lookup_filter = forward_lookup_filter,
        update_endpoints = function (config, endpoints)
          for _, endpoint in pairs(endpoints) do
            local skip_hostnames = {
              "aqua",
              "daki",
              "mitsuru",
              "pdu1",
              "pdu2",
              "ram",
              "rem",
              "shiroko",
              "taiga",
              "ups1",
              "yor",
            }
            for _, v in pairs(skip_hostnames) do
              if v == endpoint.hostname then
                log.info("skipping updating endpoint in shimiko", {
                  hostname = endpoint.hostname,
                })
                goto continue
              end
            end
            if #endpoint.ipv4s == 0 then
              goto continue
            end
            local check = http.request({
              url = "http://localhost/v1/dns-records/A/" .. endpoint.hostname,
            })
            if check.status_code == 404 then
              goto continue
            end
            local needs_update = false
            local records = check.json().record.records
            for _, ipv4 in pairs(endpoint.ipv4s) do
              local matches = false
              for _, record in pairs(records) do
                if record == ipv4 then
                  matches = true
                end
              end
              if not matches then
                needs_update = true
              end
            end
            if not needs_update then
              log.info("skipping noop shimiko update", {
                hostname = endpoint.hostname,
                endpoint_ipv4s = endpoint.ipv4s,
                records = records,
              })
              goto continue
            end
            -- TODO: make this one big upsert request instead of a bajillon
            -- tiny ones
            local req = {
              url = "http://localhost/v1/dns-records/A/" .. endpoint.hostname,
              method = "POST",
              json = {
                record = {
                  name = endpoint.hostname,
                  type = "A",
                  records = endpoint.ipv4s,
                },
              },
            }
            log.info("making request", {
              request = {
                url = "http://localhost/v1/dns-records/A/" .. endpoint.hostname,
                method = "POST",
                json = {
                  record = {
                    name = endpoint.hostname,
                    type = "A",
                    records = endpoint.ipv4s,
                  },
                },
              },
            })
            local res = http.request({
              url = "http://localhost/v1/dns-records/A/" .. endpoint.hostname,
              method = "POST",
              json = {
                record = {
                  name = endpoint.hostname,
                  type = "A",
                  records = endpoint.ipv4s,
                },
              },
            })
            if res.status_code ~= 200 then
              log.error("got error response", {
                request = req,
                response = res,
              })
              error("shimiko request failed: status="..res.status_code..", body="..res.body)
            end
            log.info("got response", {
              request = req,
              response = {
                status_code = res.status_code,
                headers = res.headers,
                body = res.body,
                json = res.json(),
              },
            })
            ::continue::
          end
        end
      },
    },
    prometheus = {
      "prometheus_metrics",
      config = {
        source_labels = {
          "dhcp_pool",
          "hardware_address",
          "source",
        },
        provider_labels = {},
      },
    },
    http = {
      "http",
      config = {},
    },
  },
}
